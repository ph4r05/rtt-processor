#!/usr/bin/env python
# -*- coding: utf-8 -*-

import math
import logging
import sys
from jsonpath_ng import parse
from typing import Optional

from .ranking import rank, unrank, comb_cached

if sys.version_info >= (3, 2):
    from functools import lru_cache
else:
    from repoze.lru import lru_cache


logger = logging.getLogger(__name__)


@lru_cache(maxsize=4098)
def parse_jpath(path):
    return parse(path)


def jsonpath(path, obj, allow_none=False):
    r = [m.value for m in parse_jpath(path).find(obj)]
    return r[0] if not allow_none else (r[0] if r else None)


def make_ctr_config(blen=31, offset='00', tv_count=None, min_data=None, seed=None):
    """
    Generate counter CryptoStreams config with configurable offset.
     - blen is block width in bytes
     - offset is MSB hex-coded byte to distinguish counter sequences
     - tv_count is desired number of output blocks. If None, set to the maximal value
     - min_data if set, require that number of data generated by the script is at least min_data, raises otherwise
    """
    max_vals = 2**((blen-1)*8) - 1
    tv_count = min(tv_count or max_vals, 2**62)
    data_mb = blen * tv_count / 1024 / 1024

    if len(offset) != 2:
        raise ValueError('Offset has to be hex-coded byte')

    if max_vals < tv_count:
        logger.info('TV count is higher than ctr space %s bits, max vals: %s'
                    % (blen-1, max_vals))

    if min_data is not None and min_data > blen * min(max_vals, tv_count) * blen:
        raise ValueError('Condition on minimal data could not be fulfilled')

    note = 'plaintext-ctr-%sbit-%.2fMB' % (blen*8, data_mb)
    ctr_file = {
        "notes": note,
        "seed": seed or "0000000000000000",
        "tv-size": None,
        "tv-count": None,
        "tv_size": blen,
        "tv_count": tv_count,
        "stdout": True,
        "file_name": "plain_ctr.bin",
        "stream": make_ctr_core(blen, offset)
      }

    return ctr_file


def make_ctr_core(blen, offset):
    return {
        "type": "xor_stream",
        "source": {
            "type": "tuple_stream",
            "sources": [
                {
                    "type": "counter",
                    "output_size": blen
                },
                {
                    "type": "single_value_stream",
                    "output_size": blen,
                    "source": {
                        "type": "tuple_stream",
                        "sources": [
                            {
                                "type": "false_stream",
                                "output_size": blen - 1
                            },
                            {
                                "type": "const_stream",
                                "output_size": 1,
                                "value": offset
                            }
                        ]
                    }
                }
            ]
        }
    }


def make_hw_config(blen=31, weight=4, offset=None, tv_count=None, offset_range: float = None, min_data=None, seed=None):
    """
    Generate HW counter CryptoStreams config with configurable offset.
     - blen is block width in bytes
     - weight is number of bits enabled
     - offset is initial combination array, |offset| == weight
     - tv_count is desired number of output blocks. If None, set to the maximal value
     - offset_range is float in [0, 1), computes offset to start in the given combination index
     - min_data if set, require that number of data generated by the script is at least min_data, raises otherwise
    """
    tv_count, offset, weight, offset_idx, offset_range, rem_vectors, gen_data_mb = comp_hw_data(
        blen, weight, offset, tv_count, offset_range, min_data
    )

    note = 'plaintext-hw-%sbit-hw%s-offsetidx-%s-offset-%s-r%.2f-vecsize-%s-%.2fMB' \
           % (blen * 8, weight, offset_idx, '-'.join(map(str, offset)), offset_range, rem_vectors, gen_data_mb)

    hw_file = {
        "notes": note,
        "seed": seed or "0000000000000000",
        "tv-size": None,
        "tv-count": None,
        "tv_size": blen,
        "tv_count": tv_count,
        "stdout": True,
        "file_name": "hw_ctr.bin",
        "stream": {
          "type": "hw_counter",
          "initial_state": offset,
          "hw": weight
        }
    }

    return hw_file


def comp_hw_data(blen=31, weight=4, offset=None, tv_count=None, offset_range: float = None, min_data=None):
    """
    Computes HW config data
     - blen is block width in bytes
     - weight is number of bits enabled
     - offset is initial combination array, |offset| == weight
     - tv_count is desired number of output blocks. If None, set to the maximal value
     - offset_range is float in [0, 1), computes offset to start in the given combination index
     - min_data if set, require that number of data generated by the script is at least min_data, raises otherwise
    """
    if offset is not None and weight != len(offset):
        raise ValueError('Offset length error')

    offset = offset or list(range(weight))
    num_vectors = comb_cached(blen*8, weight)

    if offset_range is not None:
        offset_idx = int(num_vectors * offset_range)
        offset = unrank(offset_idx, blen*8, weight)
        logger.debug('Offset computed from range %s, index %s, offset: %s'
                     % (offset_range, offset_idx, offset))
    else:
        offset_idx = rank(offset, blen*8)
        offset_range = offset_idx / num_vectors

    rem_vectors = num_vectors - offset_idx
    tv_count = min(tv_count or rem_vectors, 2**62)
    gen_data_mb = tv_count * blen / 1024 / 1024

    if tv_count > rem_vectors:
        logger.info('Number of generatable vectors is lower than desired. '
                    'Num: %s, offset: %s, remains: %s. W: %s. Offset: %s. Max generated data: %.2f MB'
                    % (num_vectors, offset_idx, rem_vectors, weight, offset, gen_data_mb))

    if min_data is not None and min_data > blen * min(rem_vectors, tv_count):
        logger.warning("Could not generate enough data, w: %s, min_data: %s, rem: %s, tvs: %s, blen: %s"
                       % (weight, min_data, rem_vectors, tv_count, blen))
        raise ValueError('Condition on minimal data could not be fulfilled')

    return tv_count, offset, weight, offset_idx, offset_range, rem_vectors, gen_data_mb


def make_hw_core(offset, weight):
    return {
        "type": "hw_counter",
        "initial_state": offset,
        "hw": weight
    }


def get_smaller_byteblock(bits):
    return bits // 8


def comp_hw_weight(blen, samples=3, min_data=None, min_samples=None):
    for hw in range(2, blen*8 // 2):
        max_combs = comb_cached(blen*8, hw)
        cur_comb = max_combs / samples

        if min_data is not None and cur_comb * blen < min_data:
            continue

        if min_samples is not None and cur_comb < min_samples:
            continue

        return hw

    raise ValueError('Could not find suitable HW')


def log2ceil(x):
    cd = math.ceil(math.log(x, 2))
    return cd if x <= 2**cd else cd+1


def augment_round_configs(to_gen):
    res = []
    for x in to_gen:
        for r in x[-1]:
            res.append(tuple(list(x[:-1]) + [r]))
    return res


def myformat(_fmtstr, **kwargs):
    for k in kwargs:
        _fmtstr = _fmtstr.replace('{{' + k + '}}', str(kwargs[k]))
    return _fmtstr


